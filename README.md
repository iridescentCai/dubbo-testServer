# Dubbo

Apache Dubbo 是一个款微服务开发框架，它提供了 RPC通信 与 微服务治理 两大关键能力。这意味着，使用 Dubbo 开发的微服务，将具备相互之间的远程发现与通信能力， 同时利用 Dubbo 提供的丰富服务治理能力，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。同时 Dubbo 是高度可扩展的，用户几乎可以在任意功能点去定制自己的实现，以改变框架的默认行为来满足自己的业务需求。

官方文档：https://dubbo.apache.org/zh/docs/v2.7/

## 1.架构演变

Dubbo是阿里巴巴公司开源的一个高性能优秀的[服务框架](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6)，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 [Spring](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/Spring)框架无缝集成。是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：

1. 面向接口的远程方法调用。
2. 智能容错和负载均衡。
3. 以及服务自动注册和发现。

### **1.1 单一应用架构：**

![img](./v2-3328d8aa2d995ba67573ae69c8c073e8_1440w.png)

当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。比如公司的管理系统，等等。

```text
优点：这样开发简单，部署也简单，直接打成war包，扔到服务器上。
缺点：扩展性很差。不利于协同开发和维护。等到项目大了变成了几百MB的时候，服务器可能吃不消。
       还有就是修改某一个模块代码后，项目得重新打包，放到服务器上运行。
       可能还有多台服务器，都得重新打包部署。
```

### **1.2 垂直应用架构：**

![img](./v2-4e65cdb232f7ddd59d2d0f17cdf15739_1440w.png)

当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。把大应用分为小应用部署，每个小应用从页面 --> 业务 --> 数据库 都是完整的。如果用户小应用并发高，那么就多放几台服务器。订单小应用访问量少，就少放几台服务器。

```text
优点：分工合作很容易，互不干扰，性能扩展容易，访问量并发高的小应用，比如用户，就多分配几台服务器。
缺点：1、无法分离页面和业务逻辑。每一个应用从头到尾都是包含 页面 --> 业务 --> 数据库，
         当公司做活动的时候，需要美化一下页面，弄完都得重新部署。
     2、应用之间不可能完全独立，需要交互。有可能以后功能扩展还会有物流应用，支付应用，
        那么应用与应用之间肯定会有交互。比如说下单的时候，肯定会查询商品库存，
        支付的时候肯定会用到订单的内容。物流又要用订单的信息等等
```

### **1.3 分布式服务架构**:

![img](./v2-a4104cdb63544d7aba1e69890180762f_1440w.png)

当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。界面和业务逻辑分开部署，单独改界面，就重新部署界面的服务器。

原来web和业务逻辑在一个服务器，那么就在服务器里通信即可，后来分开部署之后，服务之间调用就称为 RPC（Remote Procedure Call ）远程过程调用。

```text
分布式架构下，难点就是如何进行远程过程调用以及如何拆分业务，提升业务复用程度。
```

### 1.4 调度治理中心管理服务：

假如 用户应用访问量比较少，但却有100台服务器在跑，访问量比较大的商品业务，却只有10台服务器在跑。这样就造成了资源浪费。那么就应该有一个基于访问压力的调度中心，**能实时的监控这些数据，实现动态的调度，提高资源的利用率**，给访问量高的应用提高几台服务器，访问量低的应用减少几台服务器。这时候就可以**采用流动计算架构**。

当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键,Dubbo提供的监控中心可以解决这些问题.

![img](./v2-14784f8726e8844d9a686271cc519e0a_1440w.png)

## 2.基本介绍

### 2.1 基本架构

服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。

实现服务发现的方式有很多种，Dubbo 提供的是一种 Client-Based 的服务发现机制，通常还需要部署额外的第三方注册中心组件来协调服务发现过程，如常用的 Nacos、Consul、Zookeeper 等，Dubbo 自身也提供了对多种注册中心组件的对接，用户可以灵活选择。

Dubbo 基于消费端的自动服务发现能力，其基本工作原理如下图：

![//imgs/architecture.png](./architecture.png)



**服务提供者（Provider）**：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。

**服务消费者（Consumer）**:调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。

**注册中心（Registry）**：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者

**监控中心（Monitor）**：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心



### 2.2 优良特性：

![img](/Users/caicai/Desktop/dubbo/v2-d209f5b7d604b17abf37bf76938dd76a_1440w.png)



### 2.3 服务自动注册与发现：

![img](./v2-7ff2deec837cb2fb0ce3ca2ef7899b06_1440w.png)

为了能动态感知，可以把所有的服务都注册到注册中心中，这个注册中心中就有一个列表清单。描述的是，用户业务在1，3，5机器，订单业务在2，4，6机器上等等，包括哪一台机器宕机挂掉了，注册中心就会把这台机器从这个清单里删除。当web请求的时候，就可以去先问注册中心里，有没有某个业务注册，有的话，就会去访问，可以是按照负载均衡机制去访问，然后与那个服务建立连接，通信数据。

## 3.快速入门

Dubbo整合spring的快速入门很简单 详见https://dubbo.apache.org/zh/docs/v2.7/user/quick-start/

下面主要介绍Dubbo整合spirng-boot,注册中心的话因为官方推荐的是nacos和zookeeper，所以我这里演示的也是这俩注册中心.所以得先准备一个nacos和zookeeper环境 直接官网上把包下下来脚本跑起来就行了.

## 4.Dubbo进阶

### 4.1负载均衡

2.6版本默认四种均衡策略. 2.7版本有更新,但差别不大

![截屏2021-07-16 下午3.01.26](./截屏2021-07-16 下午3.01.26.png)

下面一一介绍这四种负载均衡策略

* **RandomLoadBalance:按权重随机调用，这种方式是dubbo默认的负载均衡策略**

实现思路很简单：如果服务多实例权重相同，则进行随机调用；如果权重不同，按照总权重取随机数

根据总权重数生成一个随机数，然后和具体服务实例的权重进行相减做偏移量，然后找出偏移量小于0的，比如随机数为10，某一个服务实例的权重为12，那么10-12=-2<0成立，则该服务被调用，这种策略在随机的情况下尽可能保证权重大的服务会被随机调用。

* **RoundRobinLoadBalance：轮询，按公约后的权重设置轮询比率**

实现思路：首先计算出多服务实例的最大最小权重，如果权重都一样（maxWeight=minWeight），则直接取模轮询；如果权重不一样，每一轮调用，都计算出一个基础的权重值，然后筛选出权重值大于基础权重值得invoker进行取模随机调用。

* **LeastActiveLoadBalance：最少活跃次**

  dubbo框架自定义了一个Filter，用于计算服务被调用的次数.最小活跃次数思路：首先查找最小活跃数的服务并统计权重和出现的频次，如果最小活跃次数只出现一次，直接使用该服务；如果出现多次且权重不相同，则按照总权重数随机；如果出现多次且权重相同，则随机调用

* **ConsistentHashLoadBalance：一致性hash**

一致性Hash负载均衡涉及到两个主要的配置参数为hash.arguments 与hash.nodes。

hash.arguments ： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点

hash.nodes： 为结点的副本数。

* **自定义负载均衡策略**

自定义类，只需要实现AbstractLoadBalance抽象类即可，然后将该类放入dubbo可发现的扩展点即可。

只有标有@SPI注解的接口类才会查找扩展点的实现，dubbo依次从下面这三个路径读取扩展点文件：META-INF/dubbo/internal 、META-INF/dubbo/ 、META-INF/services/，其中dubbo内部实现的各种扩展文件都放在META-INF/dubbo/internal目录下面.



**然而在代码中使用只需要在 @DubboService 注解上添加负载均衡策略属性就好 缺省值是random**.



### 4.2 降级机制

#### 4.2.1 mock机制

1.mock="return null"，即当服务提供者出现异常（宕机或者业务异常），则返回null给服务消费者。

```java
public class DubboConsumerApplication{
    
    @DubboReference(version = "1.0.0", group = "DubboTest3", retries = 1, mock = "return \" 此服务已熔断限流 \"")
    private TestInterface testInterface3;
    
    //.....
}
```

2.服务消费者mock属性设置为true+Mock实现类

```java
package com.caicai;

/**
 * @author caicai
 * @Date 2021/7/16 下午3:23
 */

public class TestInterfaceMock implements TestInterface {
    @Override
    public String test() {
        return "Mock实现类-服务降级了";
    }
}

```

#### 4.2.2 dubbo降级缺陷分析

其实经过上面的例子分析和源码分析，我们会发现一个问题：由于 dubbo 不带熔断机制，所以尽管每次因为 RPC 异常而导致调用失败，也不会进行熔断处理；即不管调用失败多少次，消费者还是会继续进行调用。

其实这样会导致服务的资源浪费：

- 只要服务提供者出现异常达到一定的次数，其实可以理解为服务提供者短时间内已经不能正常提供服务了，后续再调用也是浪费资源。
- 如果是上述的超时问题，消费者还会进行 1+retires 次的 RPC 调用，这样就更加浪费资源了。

所以，为 dubbo 配一个熔断机制是非常有必要的了。

### 4.3 dubbo熔断及限流

引入sentinel和sentinel-dashboard

pom文件引入jar包

```pom
        <dependency>
            <groupId>com.alibaba.csp</groupId>
            <artifactId>sentinel-apache-dubbo-adapter</artifactId>
            <version>1.8.2</version>
        </dependency>
```

然后配置下jvm启动参数启动就完事了![截屏2021-07-16 下午3.44.17](./截屏2021-07-16 下午3.44.17.png)



启动sentinel-dashboard 调用一次接口 sentinel-dashboard主页上就可以监控你的dubbo接口了

![截屏2021-07-16 下午4.43.57](./截屏2021-07-16 下午4.43.57.png)

在这里你可以监控接口流量,定义流控规则降级规则等等 具体怎么配置可以看官方文档 

https://sentinelguard.io/zh-cn/docs/flow-control.html



代码地址:    **https://github.com/iridescentCai/dubbo-testServer.git**



## 5.Dubbo总体分层

Dubbo的总体分为业务层(Biz)、RPC层、Remote H层。如果把每一层继续做细分，那么一共可以分为十层。其中，Monitor层在最新的官方PPT中并不再作为单独的一层。如图：![截屏2021-07-16 下午5.04.38](./截屏2021-07-16 下午5.04.38.png)

所示，图中左边是具体的分层, 右边是该层中比较重要的接口。Service和Config两层可以认为是API层，主要提供给API使用者，使用者无须关心底层 的实现，只需要配置和完成业务代码即可;后面所有的层级合在一起，可以认为是SPI层，主要提供给扩展者使用，即用户可以基于Dubb。框架做定制性的二次开发，扩展其功能。Dubbo 的扩展能力非常强，这也是Dubbo一直广受欢迎的原因之一。

每一层都会有比较核心的接口来支撑整个层次的逻辑，如果需要阅读源码，则可以从这些核心接口开始，梳理整个逻辑过程。如图是每一层的作用：

![截屏2021-07-16 下午5.08.26](./截屏2021-07-16 下午5.08.26.png)



## 6.Dubbo总体调用过程

我们先介绍一下服务的暴露过程。首先，服务器端(服务提供者)在框架启动时，会初始化服务实例，通过Proxy组件调 用具体协议(Protocol ),把服务端要暴露的接口封装成Invoker (真实类型是 AbstractProxylnvoker), 然后转换成Exporter,这个时候框架会打开服务端口等并记录服务实例 到内存中，最后通过Registry把服务元数据注册到注册中心。这就是服务端(服务提供者)整 个接口暴露的过程。读者可能对里面的各种组件还不清楚，下面就讲解组件的含义:

* Proxy组件:我们知道，Dubbo中只需要引用一个接口就可以调用远程的服务，并且 只需要像调用本地方法一样调用即可。其实是Dubbo框架为我们生成了代理类，调用 的方法其实是Proxy组件生成的代理方法，会自动发起远程/本地调用，并返回结果, 整个过程对用户完全透明。

* Protocol:顾名思义，协议就是对数据格式的一种约定。它可以把我们对接口的配置, 根据不同的协议转换成不同的Invoker对象。例如:用DubboProtocol可以把XML文 件中一个远程接口的配置转换成一个Dubbolnvokero

- Exporter:用于暴露到注册中心的对象，它的内部属性持有了 Invoker对象，我们可以 认为它在Invoker上包了一层。

- Registry:把Exporter注册到注册中心。  

  

  以上就是整个服务暴露的过程，消费方在启动时会通过Registry在注册中心订阅服务端的元数据(包括IP和端口)。这样就可以得到刚才暴露的服务了。 下面我们来看一下消费者调用服务提供者的总体流程. 

  ![截屏2021-07-16 下午5.15.05](./截屏2021-07-16 下午5.15.05.png)

首先，调用过程也是从一个Proxy开始的，Proxy持有了一个Invoker对象。然后触发invoke 调用。在invoke调用过程中，需要使用Cluster, Cluster负责容错，如调用失败的重试。Cluster在调用之前会通过Directory获取所有可以调用的远程服务Invoker列表(一个接口可能有多个 节点提供服务)。由于可以调用的远程服务有很多，此时如果用户配置了路由规则(如指定某些 方法只能调用某个节点)，那么还会根据路由规则将Invoker列表过滤一遍。

然后，存活下来的Invoker可能还会有很多，此时要调用哪一个呢?于是会继续通过 LoadBalance方法做负载均衡，最终选出一个可以调用的Invokero这个Invoker在调用之前又会 经过一个过滤器链，这个过滤器链通常是处理上下文、限流、计数等。

接着，会使用Client做数据传输，如我们常见的Netty Client等。传输之前肯定要做一些私 有协议的构造，此时就会用到Codec接口。构造完成后，就对数据包做序列化(Serialization), 然后传输到服务提供者端。服务提供者收到数据包，也会使用Codec处理协议头及一些半包、 粘包等。处理完成后再对完整的数据报文做反序列化处理。

随后，这个Request会被分配到线程池(ThreadPool)中进行处理oServer会处理这些Request, 根据请求查找对应的Exporter (它内部持有了 Invoker)0 Invoker是被用装饰器模式一层一层套 了非常多Filter的，因此在调用最终的实现类之前，又会经过一个服务提供者端的过滤器链。

最终，我们得到了具体接口的真实实现并调用，再原路把结果返回。 

至此，一个完整的远程调用过程就结束了。
